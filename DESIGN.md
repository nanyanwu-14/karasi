#Choose Your Own Apocalypse
The overall goal of our website is to generate a custom story for a user based on their decisions in individual chapters.

#Database
The apocalypse.db database contains five tables: plays, important_decisions, stories, chapters, and users. The chapters table contains the name and number of each chapter in the story and the users table stores the username, id, and hashed password for each user. The other three tables specifically relate to the individual playthroughs of each user. The content and function of the other three tables will be subsequently discussed.

#Register
The first page of our site is a login page. From this page, users can login or access the /register route to create an account. When the /register route is accessed through a GET request the register.html file is rendered. Upon rendering, the user is presented a form asking for their username, password, and password confirmation. When this form is submitted, it is sent to the server python code through a POST route. The server then checks that the username, password, and password confirmation contain text and are alphanumeric. The username must also not already exist and have at least 4 characters while the password and password confirmation must match, have at least 8 characters, and contain one special character (!, *, etc.). These requirements were made in order to increase username and password variability. After registration is complete, the user will automatically be redirected to the login page.

#Login
At the login page, the user is presented with a form for the username and password. When entered a POST request is sent to the /login route. The server checks that the username and password fields were not left blank and query the database for a matching username and password. If these conditions are met, the user will be redirected to the home page through the / route, otherwise the login.html file will be reloaded, with a prompt for the user to correct their mistakes.

#Index
When the / route is accessed, the server will use the user’s session id to access a table in the apocalypse.db database named “plays”. This table contains all of the information about an individual user’s past playthroughs. This includes the identification number of their playthroughs, their session id, their character’s name and pronouns in past plays, the chapter number they left off on, the date they started the playthrough, and more. The table was constructed in this manner to neatly organize all data associated with individual playthroughs. When the user makes a GET request to the / route, their session id is used to access all of this information in the plays table. This occurs in the index() function. The function extracts the information associated with a single user from the table as a dictionary. In order to increase the specificity of the site, an additional key-value pair is added depending on if the user has completed a shown playthrough. If a playthrough is completed, the key-value pair will be ‘word: View’; if not completed the key-value pair will be ‘word: Continue’. This key-value pair is used later on when the table is rendered and shown to the user. The function then renders the dictionary containing all playthrough information to the index.html file. Jinja for loops were utilized to generate a table containing the user’s previous playthrough dates, characters’ names, and the last chapter numbers in a table. The table also contains the button ‘Delete’ and the button ‘View’ or ‘Continue’. The View/Continue button links to the same route which later be discussed. Their only difference is the words displayed to the user.

After rendering index.html, the user has a variety of potential pathways. The user can start a new story, view the story’s creative decisions, logout, continue or view a previous story, and delete a previous story.

#Continue/View and Delete
On the index page of the site, the user is presented with a table containing the name, date started, current chapter, option to delete, and option to continue/view for each playthrough by the means previously described. When either a continue or delete button is clicked, a form is submitted to index via POST.  Then, by checking what form element was submitted the user is either redirected to chapters (view/continue clicked), or the entries for the selected playthrough in each table of the database are deleted and the user is rerouted to index via GET.

#Logout
When the user clicks the ‘Logout’ hyperlink, the user’s id in the session is cleared and the user is logged out. The user is then redirected to the login form with the / route.

#Creative Decisions
When the ‘Creative Decisions’ hyperlink is clicked a GET request is made to the route /creative. When a request is made to this route, the python server opens and reads a textfile called ‘creative.txt’. The text is parsed according to the symbols ‘||’ and ‘//’ and made into a paragraph list. Using a for loop, the paragraphs list is appended to include just the words and account for the empty space. The title text (representing each subsection title) is parsed according to the symbols ‘##’ and '//'. An essay list is created with the paragraph and title acting as the key. Each element of the essay list is appended to a dictionary, rendered to creative.html using a for loop to generate each section (title and paragraphs). Creative.html includes a heading ‘Creative Decisions’ in gold and a riptape font red ‘Legend of Karasi’ subheading. The html file contains Jinja that for each section in creative.txt, grabs the section titles and paragraphs.

#New Story
When the ‘New Story’ hyperlink is clicked a GET request is made to the route /new. When a GET request is made to this route, the python server will simply render new.html. An html file that contains a form. The form will prompt the user to enter their character’s name and select their character’s pronouns from a dropdown list. When submitted a POST request will be made to the python server through the same /new route. The python server in response to this POST request will perform two key checks.

Firstly, the server will check the number of plays a user currently has in the database. If a user has more than ten active plays, they will be prompted to delete a play in order to make a new one. This feature was added to ensure that the database would not become full of a large amount of information and run slower. In order to delete a play, a user must return to the index by selecting the hyperlinked text ‘Legend of Karasi’ and pressing the delete button associated with that playthrough. Upon pressing, a POST request will be sent to the / route and any information associated with the selected playthrough will be deleted from the apocalypse.db database.

Afterward, if the user has less than ten active plays the server will request the character’s name and pronouns from the form. If the pronouns have not been selected or the character’s name has not been entered, an appropriate alert will be shown to the user and the page will be reloaded. Otherwise, if the character name has been entered and pronouns have been selected, the user will be assigned an identification number for the playthrough and redirected to the /chapters route through a GET request with this identification number, play_id, in the web address.

#Chapters (Upon the first playthrough of a chapter)
The /chapters route essentially serves the role of rendering the various text chapters into a html file. When /chapters is accessed via a GET request, it will obtain the user’s current play\_id from the web address. Afterward, it will obtain all of the current playthrough data from the plays table that corresponds to this play\_id. It will then check if the user is at the end of the story - ch\_number == 11, if so it will set the current playthroughs chapter to 1 and redirect the user through the /breakdown route. This route will be further explained subsequently, but it essentially displays the final character archetype for a playthrough. Otherwise, on the first playthrough of a chapter, the /chapters route will dynamically generate a url that corresponds to the location of that chapter’s text file. This is done by obtaining the current chapter number from the plays database, converting this integer to a string, and concatenating it to create the url chapters/chaptern.txt, where n is a chapter number. This url will be used to obtain the chapter text file from the chapters folder. Once the text file is obtained, a specifically designed function called text\_process will process it. The text\_process function and its output will be subsequently discussed. After the text is processed, it will be rendered to either the html file chapter\_simple.html or the file chapters.html. chapter\_simple.htm> renders all of the chapters that do not have any user decisions and are therefore just plain text files. The antithesis is done by chapters.html- chapters that have user input are rendered to this file. This distinction is made by the server using the global EXCEPT\_CHS list; in this list, all of the chapters that do not have any user decisions are written, those chapters being chapters 1, 5, and 9. A special case however occurs for chapter 4. Based on previous user decisions, either chapter4dead.txt or chapter4alive.txt will be processed and rendered. Since chapter4alive.txt does not contain any user decisions, chapter_simple.html will be rendered, while chapter4dead.txt is rendered with chapters.html since it has user decisions. The dynamic creation of text file urls and rendering of text was done to minimize the number of html files and routes used by the webpage. It also significantly simplifies script that would have otherwise been much longer.

#Text_process
The aforementioned text\_process function takes a text and playthrough id as inputs and returns processed text. To process the text for each chapter, the string method ‘split’ was thoroughly used. Firstly, all of the text files were formatted with unique markers where splits should occur. The main text for a chapter was split into a list where each index represents a section of the chapter before a user decision occurs. The user decisions that would affect the story’s narrative were split into a list of lists initially. Each sub-list contains all of the options the user can choose from at a point in the story. Each index of the list reflects a section in the story, where index 0 are the options presented immediately after the text in the main text list’s 0 index. The results or routes generated from each of these options were sectioned into an identically structured list of lists. The apocalyptic archetypes associated with each of these story routes were also sectioned into an identically structured list of lists. After the formation of these structures, all four are combined to generate the whole chapter list variable. The variable chapter is a list of dictionaries. Similar to the previously mentioned lists, each index of this list corresponds to a section of the chapter. However, these list indices are filled with dictionaries, with keys of ‘main’ and ‘optroute’. The key ‘main’ corresponds to the main text for that individual section. The key ‘optroute’ corresponds to another dictionary. The keys to this dictionary are the user decisions for a specific section of text. The value of these keys is their unique text response and the apocalyptic archetype. As a result, each user choice is directly associated with its consequent text and apocalyptic archetype. After splitting, the chapter’s title is also stored as a string. The last step in the function is the processing of conditionals. Because there are unique user decisions, the written story also has slightly different storylines triggered by these user decisions. The method by which these key decisions were accounted for will be later discussed in ‘Process_decisions’. These conditionals do not occur for every chapter, but for the chapters that they do occur in, they are attached to their corresponding main text section. The conditionals are processed by checking if an inputted condition is true or false. The database is queried for these true or false occurrences using the condition. The text specific to the condition’s current state is concatenated to the main story text using the find method of strings. In the text file, the user must enter the sentence that comes immediately before the conditional text. Afterward, find is used in a loop through all of the main story sections for this text. When a main story section with the condition signaling text is found, the conditional text is appended to it. After this process is complete, the chapter and title are returned. This approach to text processing allowed for easy carryover to Javascript and also highly-organized the various elements in a chapter.

#HTML Text Rendering
After the text for a chapter is processed, it is rendered by either chapter\_simple.html or chapters.html. Since chapter_simple only renders plain text with no options, it simply loads the first index of the chapter variable with the key ‘main’. All of the chapter’s text is located in this position since no user choices occur.

The chapters.html file on the other hand goes through a much more dynamic process to load the chapter. Firstly, a Jinja loop is used to generate several dividers containing main storyline text in p tags, the buttons that come immediately after these text tags, and empty p tags. The ids of these elements are assigned using loop.index where the dividers’ ids follow the pattern, 1, 2, 3, n; the buttons ids follow the pattern, 1-1, 1-2, 2-1, n-m; and the empty p tags follow the pattern, e1, e2, e3, en. The main storyline p tags did not have ids. The ids for the dividers and empty p tags are in order and correspond to the indices in the chapter list by ‘chapter[i] = div id= i + 1’.  For the buttons, the first number in the id, before the dash, is related to the indices in the chapter list the same way. The second number, however, represents a button’s number within its button group- the buttons in its section. The assignment of these ids was essential for subsequent Javascript.

#Javascript was used to dynamically select the p tags containing main text and the buttons. This dynamic assignment was done using the eval function in Javascript. After selection, an event listener for click was added to all of the button elements. The function firstly plays audio on the site. Audio already is set to play on the site but in Google Chrome reloading a page stops this audio if there is no user interaction with the page. As a result, this addition was made to the Javascript function. Another stylistic feature occurs after the playing of audio. After the first button on the page has been clicked and the user has officially begun the chapter, hovering over any site hyperlinks will flash a warning that navigation away from the page will cause current decisions to be lost. This warning was implemented to improve the site’s user interface. Afterward, when a button from the first button group on the page is clicked, the ‘previous chapter’ button will be hidden, if applicable. The previous chapter button and route will be later discussed, but this was implemented to prevent users from going back to a previous chapter in the middle of a new one. Not doing so would have also resulted in current decisions being lost if the previous button was pressed. The buttons then plug the text that corresponds to the user’s choice into the previously mentioned empty p tags. The specific choice the user made is also stored in a list to be eventually sent back to the server through a hidden form. All of the buttons in the now clicked button group are then hidden and the next section of text and buttons is revealed. Some variations to the function are also present for specific chapters. These variations are as follows:

#If the user is on chapter 6, the function removes break tags from the first divider section. These break tags were added with Javascript outside of the function because the webpage’s background did not cover the whole page when chapter 6 was loaded. After the button click, these tags are removed to prevent incorrect spacing between text.

-If the user is on a chapter with no final button, as specified in the list variable no\_end\_button, there is a slight difference in the Javascript for when the user is at the final text section. Most chapters in the story end with final button options. In this event, the buttons and the text before these buttons are shown together since they are in the same divider, and the text from the user’s final choice is inputted into the empty p tag as the buttons disappear. In chapters that end without final button options and just with text though, this functionality results in empty buttons with undefined values. As a result, these specified chapters are processed differently; the excess button is hidden and just the text for the section is shown.

#When all the button groups for the chapter have been clicked, the user’s uniquely generated story is selected through querySelector and entered into a hidden p tag. The ‘next chapter’ button, a submit button for a hidden form that routes to /forward, also is shown. The form posts the user’s playthrough id number, generated story, and specific choices back to the server to be processed.

#Forward
In the /forward route (POST method), the user’s play\_id will be retrieved. The current chapter information is also retrieved from the database based on the user’s current play\_id, specifically chapter number and chapter name. The chapter number is then updated in the database by adding +1 to the current chapter\_numer. After updating, the forward function then routes to the /chapters route through a GET request with the play\_id in the url. The text is then loaded and rendered. If the next chapter has already been played through before, the text is retrieved from the database and the played.html template is rendered. Played.html displays the title of the chapter, the loaded text, and the next and previous chapter buttons. However, if the user is currently at chapter 10, the archetype with the most points is selected and only the button with that archetype is shown (reveal your ending) using Javascript. The helper function get\_arch is used to select the four archetypes (Christ, AntiChrist, Prophet, and Survivalist) from the plays database based on the user’s playthrough id. The user’s main\_archetyp> is displayed using a highest(player) function. The highest function retrieves the user’s score for each archetype based on their previous decisions from button presses (each button is associated with an archetype). If a new chapter has not been loaded or played through and the previous chapter has not been loaded, the completed chapters are saved and user decisions are processed with process_decisions.

#Process_decisions
The process\_decisions function has the general purpose of storing the choices of a user after they have completed a chapter for the first time. The function is called in the /forward route, in the case that the user has no record of already completing the chapter they will be moving forward to. To process the choice made in the chapter just read, first, the function verifies that the chapter is one in which decisions are made, by checking if it is not in the global array EXCEPT\_CHS. Then, the function opens the appropriate text file for the chapter and makes a call to text\_process to obtain the choice information for that chapter in a manageable form. Then, the function requests the choices made by the user by pulling them from the javascript form submitted when next chapter is clicked. Then, for each place where the user can make a choice within the chapter, the specific choice they made is used as a key to a dictionary whose corresponding value is the archetype associated with that choice. This archetype is appended to a list. For each archetype in that list, the user’s score in the database for that archetype is incremented by 5. Then, after processing the archetype data resulting from user decisions, the process_decisions function then determines whether that chapter contains decisions whose choice affects the broader scope of the story at later stages. If the chapter does contain such decisions, the chapter number is used as a key to the global DECISIONS dictionary, whose value is a list of the indices (as in chapter[*index*][‘optroute’]) where those choices are made. Then, if the name of the choice selected by the user is the one that causes the shift in the story (which is determined by seeing if the choice name is in the global dictionary EFFECTS), the database is updated to set the event to true (as false is default for all such decisions).

#Previous
Upon clicking the “Previous Chapter” button the user submits a form to /previous via POST. In the previous route for POST, the entry in the plays table of the database matching the play_id of the playthrough the user is reading has it’s value for current chapter incremented by -1. Afterward, the user is redirected to /previouschapter which loads the stored chapter from database into played.html to be rendered. Played.html displays the title of the chapter, the loaded text, and the next and previous chapter buttons.

#Breakdown
When users are on the final chapter, during the processing of the chapters route they will be redirected to /breakdown, where they will be presented with the archetype data for their playthrough. To do this, the function breakdown\_play is called. This function analyzes the archetype data for the player by then calling the highest function. In breakdown\_play, this function is called first to determine the primary archetype. Then, the primary archetype is removed from the dictionary, and the secondary archetype is determined by calling the function a second time. Then, for the two archetypes, a description file for the archetype is loaded, in which the appropriate pronouns for the user are inserted into the document. These two text files are then entered into a list in proper order, and the breakdown_play function returns the two archetypes along with that list. These archetypes names and descriptions are then passed into the breakdown html document. In the document, the archetypes names and descriptions are listed for the user in correct order. Additionally, using the primary archetype name in the javascript of the html document, the background image and music are generated based on the user’s primary archetype.

#Past Playthroughs
In the /past route (GET method), a query is made to the database to pull all of the user’s completed playthroughs. Additionally, for each playthrough get\_arch is called to add the primary archetype of the player to the dictionary. Then, the list of plays is passed into the past.html document, where a table containing each playthrough as a row is created. Each row contains the character name, date started, primary archetype, and two buttons to either view the story or the character breakdown (each of which have a value of the corresponding play_id). On click of either the view story or view breakdown buttons, a form is submitted to /past via POST. Then after determining which button was clicked by checking what form entries were submitted, the user is either redirected to /chapters (to view story) or /breakdown (to view breakdown).

#Style Elements

##Backgrounds:
There are two ways background images are generated, either statically or dynamically. If static, a css ‘.back’, ‘.content’, and ‘main’ method under a style tag is used to format the image so that it is centered, well proportioned, and either non-repeating or repeating across the y axis. If static, the name of the background image jpeg is hardcoded after ‘background-image:’. If dynamic, the ‘.back’ and ‘main’ methods are also used in the style tag but ‘background-image’ is not hardcoded. Instead, using JavaScript the story is loaded and the document.querySelector selects ‘.back’. An array called titles is created that includes the name of each chapter and the name of each image file. In order to apply the correct background image for each chapter title, the title array is converted to json so that it is readable by javascript and then the title number is retrieved from the titles array by looking at the second element (after the colon). Next, each title number (1,2, 3, etc.) is added to the ‘jpg’ ending and that is defined as a file.Image is then defined as ‘static/’ (representing the location of the image files in the static folder) and the file. Using, background.setAttribute('style', 'background-image: url('+image+')'); the ‘.back’ method under the style tag is dynamically changed so that the url of the specific image that corresponds to each chapter is called.

##Audio
Audio for each html page is generated by declaring a javascript audio object on event of the content loading. The path of the audio file is either generated dynamically or statically. If statically, the path to the file is encoded as a javascript variable, which is then passed into the Audio function of javascript to create the object, which is the played using the .play() method. If the audio is generated dynamically, Jinja is used to pass the appropriate file name into the javascript code. These file names vary for the different html document types, for example the appropriate audio for the breakdown.html page is the name of the user’s primary archetype. The audio is autoplayed and the volume is set to 0.1 of the original.
